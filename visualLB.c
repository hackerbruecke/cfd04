#include "visualLB.h"
#include <stdio.h>
#include "LBDefinitions.h"
#include "helper.h"
#include "computeCellValues.h"

void writeParallelVtkFile(const char * const filename, int iproc, int jproc, int kproc,
        const int * const sublength, unsigned int t)
{
    char fn[80];
    char sourceFile[256];
    FILE* fp = NULL;
    sprintf(fn, "%s_par.%d.pvts", filename, t);
    fp = fopen(fn, "w");

    /* write header */
    fprintf(fp, "<?xml version=\"1.0\"?>\n");
    fprintf(fp, "<VTKFile type=\"PStructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n");
    fprintf(fp, "\t<PStructuredGrid WholeExtent=\"0 %d 0 %d 0 %d \" GhostLevel=\"#\">\n",
            iproc * sublength[0]-1, jproc * sublength[1]-1, kproc * sublength[2]-1);

    fprintf(fp, "\t\t<PPointData>\n");
    fprintf(fp, "\t\t</PPointData>\n");

    fprintf(fp, "\t\t<PPoints>\n");
    fprintf(fp,
            "\t\t\t<PDataArray NumberOfComponents=\"3\" type=\"Float32\" name=\"velocity\" />\n");
    fprintf(fp, "\t\t</PPoints>\n");

    /* TODO: Implement parallel file */
    for (int i = 0; i < iproc; ++i) {
        for (int j = 0; j < jproc; ++j) {
            for (int k = 0; k < kproc; ++k) {
                int xa = i * sublength[0];
                xa > 0 ? --xa : xa;
                int xb = (i + 1) * sublength[0]-1;
                int ya = j * sublength[1];
                ya > 0 ? --ya : ya;
                int yb = (j + 1) * sublength[1]-1;
                int za = k * sublength[2];
                za > 0 ? --za : za;
                int zb = (k + 1) * sublength[2]-1;
                sprintf(sourceFile, "%s_%d.%d.vtk", filename, i + iproc * j + iproc * jproc * k, t);
                fprintf(fp, "\t\t<Piece Extent=\"%d %d %d %d %d %d\" Source=\"%s\"/>\n", xa, xb, ya,
                        yb, za, zb, sourceFile);
            }
        }
    }

    fprintf(fp, "\t</PStructuredGrid>\n");
    fprintf(fp, "</VTKFile>\n");
}

void writeVtkOutput(const double * const collideField, const int * const flagField,
        const char * filename, int rank, int iproc, int jproc, int kproc, unsigned int t,
        const int * const sublength)
{
    /* TODO: Replace by arb. geometry version */
    char fn[80];
    /* Save filename as a combination of passed filename and timestep */
    /*    sprintf(fn, "%s_%d.%d.%d.%i.vtk", filename, rank%iproc, rank/iproc%jproc, rank/(iproc*jproc), t);*/
    sprintf(fn, "%s_%d.%d.vtk", filename, rank, t);

    FILE *fp = fopen(fn, "w");
    if (fp == NULL) {
        ERROR("Failed to open file!");
        return;
    }

    const int xl = sublength[0];
    const int yl = sublength[1];
    const int zl = sublength[2];

    fprintf(fp, "# vtk DataFile Version 2.0\n");
    fprintf(fp, "generated by CFD-lab course output \n");
    fprintf(fp, "ASCII\n\n");
    fprintf(fp, "DATASET STRUCTURED_GRID\n");
    fprintf(fp, "DIMENSIONS %d %d %d \n", xl, yl, zl);
    fprintf(fp, "POINTS %d float\n\n", xl * yl * zl);
    /* (xl+1)*(yl+1)*(zl+1) */
    /* Print lattice points */
    for (int z = 0; z < zl; ++z) {
        for (int y = 0; y < yl; ++y) {
            for (int x = 0; x < xl; ++x) {
                fprintf(fp, "%d %d %d\n", x, y, z);
            }
        }
    }
    fprintf(fp, "POINT_DATA %d \n\n", xl * yl * zl);
    fprintf(fp, "VECTORS velocity float\n");
    double density;
    double vel[D];
    const double *currentCell;
    /* Compute (macroscopic) velocities for all cells */
    for (int z = 1; z < zl + 1; ++z) {
        for (int y = 1; y < yl + 1; ++y) {
            for (int x = 1; x < xl + 1; ++x) {
                currentCell = &collideField[idx(sublength, x, y, z, 0)];
                computeDensity(currentCell, &density);
                computeVelocity(currentCell, &density, vel);
                fprintf(fp, "%f %f %f\n", vel[0], vel[1], vel[2]);
            }
        }
    }

    /*fprintf(fp, "\nPOINT_DATA %d \n", xl*yl*zl);*/
    fprintf(fp, "SCALARS density float 1 \n");
    fprintf(fp, "LOOKUP_TABLE default \n");

    /* Compute density for each cell */
    for (int z = 1; z < zl + 1; ++z) {
        for (int y = 1; y < yl + 1; ++y) {
            for (int x = 1; x < xl + 1; ++x) {
                currentCell = &collideField[idx(sublength, x, y, z, 0)];
                computeDensity(currentCell, &density);
                fprintf(fp, "%f\n", density);
            }
        }
    }
    if (fclose(fp)) {
        ERROR("Failed to close file!");
        return;
    }
}

