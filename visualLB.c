#include "visualLB.h"
#include <stdio.h>

#include "LBDefinitions.h"
#include "helper.h"
#include "computeCellValues.h"

void writeParallelVtkFile(const char * const filename, int iproc, int jproc, int kproc,
        const int * const sublength, unsigned int t)
{
    char fn[80];
    char sourceFile[256];
    FILE* fp = NULL;
    sprintf(fn, "%s_par.%d.pvts", filename, t);
    fp = fopen(fn, "w");

    /* write header */
    fprintf(fp, "<?xml version=\"1.0\"?>\n");
    fprintf(fp, "<VTKFile type=\"PStructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n");
    fprintf(fp, "\t<PStructuredGrid WholeExtent=\"0 %d 0 %d 0 %d \" GhostLevel=\"1\">\n",
            iproc * sublength[0]-1, jproc * sublength[1]-1, kproc * sublength[2]-1);
    /*
    fprintf(fp, "\t\t<PPointData Scalars=\"density\" Vectors=\"velocity\">\n");

    fprintf(fp, "\t\t\t<DataArray type=\"Float32\" Name=\"velocity\" NumberOfComponents=\"3\" />\n");
    fprintf(fp, "\t\t\t<DataArray type=\"Float32\" Name=\"density\" />\n");

    fprintf(fp, "\t\t</PPointData>\n");
    fprintf(fp, "\t\t<PCellData></PCellData>\n");
    */

    fprintf(fp, "\t\t<PPoints>\n");

    fprintf(fp,
            "\t\t\t<PDataArray NumberOfComponents=\"3\" type=\"Float32\" />\n");

    fprintf(fp, "\t\t</PPoints>\n");

    /* TODO: Implement parallel file */
    for (int k = 0; k < kproc; ++k) {
        for (int j = 0; j < jproc; ++j) {
            for (int i = 0; i < iproc; ++i) {
                int xa = i * sublength[0];
                xa > 1 ? --xa : xa;
                int xb = (i + 1) * sublength[0]-(i==iproc-1);

                int ya = j * sublength[1];
                ya > 1 ? --ya : ya;
                int yb = (j + 1) * sublength[1]-(j==jproc-1);

                int za = k * sublength[2];
                za > 1 ? --za : za;
                int zb = (k + 1) * sublength[2]-(k==kproc-1);


                sprintf(sourceFile, "%s_%d.%d.vts", filename, i + iproc * j + iproc * jproc * k, t);
                fprintf(fp, "\t\t<Piece Extent=\"%d %d %d %d %d %d\" Source=\"%s\"/>\n", xa, xb, ya,
                        yb, za, zb, sourceFile);
            }
        }
    }

    fprintf(fp, "\t</PStructuredGrid>\n");
    fprintf(fp, "</VTKFile>\n");
}

void writeVtkOutput(const double * const collideField, const int * const flagField,
        const char * filename, int rank, int iproc, int jproc, int kproc, unsigned int t,
        const int * const sublength)
{
    /* TODO: Replace by arb. geometry version */
    char fn[80];
    /* Save filename as a combination of passed filename and timestep */
    /*    sprintf(fn, "%s_%d.%d.%d.%i.vtk", filename, rank%iproc, rank/iproc%jproc, rank/(iproc*jproc), t);*/
    sprintf(fn, "%s_%d.%d.vtk", filename, rank, t);

    FILE *fp = fopen(fn, "w");
    if (fp == NULL) {
        ERROR("Failed to open file!");
        return;
    }

    const int xl = sublength[0];
    const int yl = sublength[1];
    const int zl = sublength[2];
#if 0
    fprintf(fp, "<?xml version=\"1.0\"?>\n");
    fprintf(fp, "<VTKFile type=\"StructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n");
    fprintf(fp, "\t<StructuredGrid WholeExtent=\"0 %d 0 %d 0 %d\" >\n", xl+2, yl+2, zl+2);
    fprintf(fp, "\t<Piece Extent=\"0 %d 0 %d 0 %d\" >\n", xl+2, yl+2, zl+2);

    fprintf(fp, "\t\t<PointData Vectors=\"velocity\">\n");
    fprintf(fp, "\t\t\t<DataArray Name=\"velocity\" type=\"Float32\" />\n");
    fprintf(fp, "\t\t</PointData>\n");

    fprintf(fp, "\t\t<PointData Scalars=\"density\">\n");
    fprintf(fp, "\t\t\t<DataArray Name=\"density\" type=\"Float32\" />\n");
    fprintf(fp, "\t\t</PointData>\n");
    fprintf(fp, "\t\t<Points></Points>");

    fprintf(fp, "\t</Piece>\n");
    fprintf(fp, "\t</StructuredGrid>\n");
    fprintf(fp, "</VTKFile>\n");
#endif

    fprintf(fp, "# vtk DataFile Version 2.0\n");
    fprintf(fp, "generated by CFD-lab course output \n");
    fprintf(fp, "ASCII\n\n");
    fprintf(fp, "DATASET STRUCTURED_GRID\n");
    fprintf(fp, "DIMENSIONS %d %d %d \n", xl, yl, zl);
    fprintf(fp, "POINTS %d float\n\n", (xl) * (yl) * (zl));

    /* Print lattice points */
    for (int z = 1; z < zl+1; ++z) {
        for (int y = 1; y < yl+1; ++y) {
            for (int x = 1; x < xl+1; ++x) {
                fprintf(fp, "%d %d %d\n", x, y, z);
            }
        }
    }
    fprintf(fp, "POINT_DATA %d \n\n",  (xl) * (yl) * (zl));
    fprintf(fp, "VECTORS velocity float\n");
    double density;
    double vel[D];
    const double *currentCell;
    /* Compute (macroscopic) velocities for all cells */
    for (int z = 1; z < zl + 1; ++z) {
        for (int y = 1; y < yl + 1; ++y) {
            for (int x = 1; x < xl + 1; ++x) {
                currentCell = &collideField[idx(sublength, x, y, z, 0)];
                computeDensity(currentCell, &density);
                computeVelocity(currentCell, &density, vel);
                fprintf(fp, "%f %f %f\n", vel[0], vel[1], vel[2]);
            }
        }
    }

    fprintf(fp, "SCALARS density float 1 \n");
    fprintf(fp, "LOOKUP_TABLE default \n");

    /* Compute density for each cell */
    for (int z = 1; z < zl + 1; ++z) {
        for (int y = 1; y < yl + 1; ++y) {
            for (int x = 1; x < xl + 1; ++x) {
                currentCell = &collideField[idx(sublength, x, y, z, 0)];
                computeDensity(currentCell, &density);
                fprintf(fp, "%f\n", density);
            }
        }
    }

    if (fclose(fp)) {
        ERROR("Failed to close file!");
        return;
    }
}

